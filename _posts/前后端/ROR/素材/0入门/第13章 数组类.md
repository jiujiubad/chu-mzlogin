# 第十三章 数组类



## 13.1 复习数组



## 13.2 数组的创建方法

方法 1/4：`Array.new(个数, 初始值)`

```
Array.new(5)     #=> [nil, nil, nil, nil, nil]
Array.new(5, 0)  #=> [0, 0, 0, 0, 0]
```

方法 2/4：创建不包含空白的字符串数组时，可以使用 `%w`

```
%w()  #=> []
%w(Ruby Perl Python)  #=> ["Ruby", "Perl", "Python"]
```

方法 3/4：创建符号（Symbol）数组的 `%i`

```
%i()  #=> []
%i(Ruby Perl Python)  #=> [:Ruby, :Perl, :Python]
```

方法 4/4：对用逗号或者空白间隔的字符串使用 `split` 方法，也可以创建数组。测试发现，逗号的好像不行

```
"foo,bar,234".split()    #=> ["foo,bar,234"]
"foo, bar, 234".split()  #=> ["foo,", "bar,", "234"]
"foo bar 234".split()    #=> ["foo", "bar", "234"]
```



## 13.3 索引的使用方法

索引的三种方法：

* *a* [*n*]——等价于方法 `a.at(n)`、`a.slice(n)`
* *a* [*n..m*] 或者 *a* [*n...m*]——等价于方法 `a.slice(n..m)`
  *  *a* [*n..m*] 表示获取从 *a* [*n*] 到 *a* [*m*] 的元素，然后用它们创建新数组
  * *a* [*n..m*] 表示获取从 *a* [*n*] 到 *a*[*m*-1] 的元素
  * 如果 `m` 的值比数组长度大，则返回的结果与指定数组最后一个元素时是一样的
* *a* [*n, len*]，表示从 *a* [*n*] 开始，获取之后的 *len* 个元素——等价于方法 `a.slice(n, len)`

```
a = [1, 3, 5]

a[0..1]   #=> [1, 3]
a[0...1]  #=> [1]

a[0..10]  #=> [1, 3, 5]

a[1, 2]   #=> [3, 5]
```

使用 []、at、slice 方法还可以对元素赋值

指定 [*n*, 0] 后，就会在索引值为 *n* 的元素前插入新元素

```
a = [1, 3, 5]
a[1, 0] = ["x", "y"]

a  #=> [1, "x", "y", 3, 5]
```

**a.values_at (n1, n2, …)**，获取索引下的元素

```
a = [1, "x", "y", 3, 5]
a.values_at(0, 3, 4)  #=> [1, 3, 5]
```



## 13.4 作为集合的数组

集合没有顺序的概念，因此 `["a", "b", "c"]`、`["b", "c", "a"]`、`["c", "b", "a"]` 就都可以被认为是同一个集合

集合的基本运算分为交集 & 和并集 | 

集合的差 ary = *ary1* - *ary2*

使用 `+` 时相同的元素可能会有多个，使用 `|` 时相同的元素只会有一个



## 13.5 作为列的数组

数据结构的队列（queue）和栈（stack）都是典型的列结构。共有的操作数据的方式：

* 追加元素
* 获取元素

队列相当于是放入水管，先进的先取出；栈相当于是放入箱子，后放进的先取出。

简单地说就是，按 A、B、C 的顺序保存数据时，按照 A、B、C 的顺序取得数据的数据结构就是队列，按照 C、B、A 的顺序取得数据的数据结构就是栈。



## 13.6 主要的数组方法

### 破坏性：

追加元素：`unshift`、`push` 等价于 `<<`

删除元素：`shift`、`pop`

引用元素：`first`、`last`

`a+b` 会『创建新数组』，`a.concat(b)` 跟 `shift` `pop` 等方法一样会『破坏性』覆盖数组 a

```
a = [1, 2]
b = [1, 2, 3]
a + b        #=> [1, 2, 1, 2, 3]

a.concat(b)  #=> [1, 2, 1, 2, 3]
a            #=> [1, 2, 1, 2, 3]
```

像 `pop` 方法、`shift` 方法那样，会改变接收者对象值的方法称为具有『破坏性』的方法。在使用具有破坏性的方法时需要特别小心，因为当有变量也引用了接收者对象时，如果接受者对象值发生了改变，变量值也会随之发生变化。

```
a = [1,2,3,4]
b = a
a.pop  #=> [1,2,3]
b      #=> [1,2,3]
```

`a.delete(b)`，『破坏性』删除数组中所有元素 b

```
a=[1,2,2,2,3]
b = a
a.delete(2)
a  #=> [1,3]
b  #=> [1,3]
```

`a.delete_at(b)`，『破坏性』删除一个元素 a[b]

```
a=[1,2,3]
b = a
a.delete_at(0)
a  #=> [2,3]
b  #=> [2,3]
```

判断数组 *a* 中的各元素 *item*，如果块的执行结果为真，则从数组 *a* 中删除 *item*。`a.delete_if{|i| i>2}` 和 `a.reject!{|i| i>2}` 方法都是具有『破坏性』的方法。

```
a = [1, 2, 3, 4, 5]
a.delete_if{|i| i > 2}
p a  #=> [1, 2]
```

`a.fill(b)`、`a.fill(b, begin)`、`a.fill(b, begin, len)`、`a.fill(b, n..m)`，『破坏性』替换数组元素为 b

### 创建新数组

`a+b`

`a.slice(b)`、`a.slice(n..m)`、`a.slice(n, len)`，删除数组的一部分

`a.uniq`，删除数组中重复的元素

`a.compact`，删除所有 `nil` 元素『创建新数组』

```
a=[1,nil,nil,2,nil]
b=a
a.compact
a  #=> [1,nil,nil,2,nil]
b  #=> [1,nil,nil,2,nil]         
```

`a.collect{|i| ...}`，用块处理过的结果『创建新数组』

`a.map{|i| ...}`，用块处理过的结果『创建新数组』

`a.flatten`，平坦化数组 a

`a.reverse`，反转数组顺序

`a.sort`、`a.sort{|i,j| ...}`，排序

`a.sort_by{|i| ...}`，根据块的结果进行排序



## 13.7 数组与迭代器

`a.each{|i| ..}`，返回的是 a

`a.collect{|i| ..}`，返回数组

```
a = 1..5
b = a.collect{|i| i += 2}
b  #=> [3, 4, 5, 6, 7]
```



## 13.8 处理数组中的元素

`for i in 1..3`

`each`

`each_with_index`



## 13.9 数组的元素



## 13.10 同时访问多个数组

```
ary1 = [1, 2, 3, 4, 5]
ary2 = [10, 20, 30, 40, 50]
ary3 = [100, 200, 300, 400, 500]

i = 0
result = []
while i < ary1.length
  result << ary1[i] + ary2[i] + ary3[i]
  i += 1
end
p result  #=> [111, 222, 333, 444, 555]
```

`zip`，将接收器和参数传来的数组元素逐一取出，而且每次都会启动块。参数可以是一个也可以是多个。

```
ary1 = [1, 2, 3, 4, 5]
ary2 = [10, 20, 30, 40, 50]
ary3 = [100, 200, 300, 400, 500]

result = []
ary1.zip(ary2, ary3) do |a, b, c|
  result << a + b + c
end
p result  #=> [111, 222, 333, 444, 555]
```

```
a = [ 4, 5, 6 ]
b = [ 7, 8, 9 ]
a.zip(b)              #=> [[4, 7], [5, 8], [6, 9]]
[1, 2, 3].zip(a, b)   #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
[1, 2].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8]]
a.zip([1, 2], [8])    #=> [[4, 1, 8], [5, 2, nil], [6, nil, nil]]
```



就像 `Comparable` 模块需要 `<=>` 运算符那样，`Enumerable` 模块则需要 `each` 方法。我们在创建提供循环处理的类的时候，可以首先创建迭代器 `each` 方法，然后再包含 `Enumerable` 模块，这样一来，`Enumerable` 的方法就都可以使用了。