# 第十二章 数值类



## 12.1 数值类的构成

`Rational`，分数计算

```
Rational(2, 5)  #=> (2/5)
```

`Complex`，复数计算

```
Complex(2, 5)  #=> (2+5i)
```



## 12.2 数值的字面量

以 `0b` 开头的数值表示 2 进制数，以 `0` 或者 `0o` 开头的数值表示 8 进制数，以 `0d` 开头的数值表示 10 进制数，以 `0x` 开头的数值表示 16 进制数。字面量中的 `_` 会被自动忽略



## 12.3 算数运算

负整数的乘方返回的结果是表示有理数的 `Rational` 对象

```
5 ** -2.0    #=> 0.04
5 ** -2      #=> (1/25)
```

除数为 0 时，`Integer` 类会返回错误，而 `Float` 类则会返回 `Infinity`（无限大）或者 `NaN`（Not a Number）

```
1 / 0         #=> 错误（ZeroDivisionError）
1 / 0.0       #=> Infinity
0 / 0.0       #=> NaN
```



## 12.4 Math 模块

提供函数，比如正弦函数 `sin(x)`，平方根函数 `sqrt(x)` 

提供常量，比如圆周率 `PI`，自然对数的底数 `e`



## 12.5 数值类型转换

转换：常用 `to_f`、`to_i`、`to_s`，少用 `to_r` 转化为分数、 `to_c` 转化为复数

处理小数：

* `round ` 四 舍五入
* `ceil` 进一
* `floor` 退一



## 12.6 位运算

`~a`，按位取反

`a & b`，与

`a | b`，或

`a ^ b`，异或（(a&~b|~a&b)）

`a >> num`，位右移

`a << num`，位左移

```
def pb(i)
  # 使用printf 的%b 格式
  # 将整数的末尾8 位用2 进制表示
  printf("%08b\n", i & 0b11111111)
end

b = 0b11110000
pb(b)              #=> 11110000
pb(~b)             #=> 00001111
pb(b & 0b00010001) #=> 00010000
pb(b | 0b00010001) #=> 11110001
pb(b ^ 0b00010001) #=> 11100001
pb(b >> 3)         #=> 00011110
pb(b << 3)         #=> 10000000
```

只用 0 和 1 的计数方式称为 2 进制。我们一般使用的计数方式是 10 进制，这种计数方式总共可表示从 0 到 9 十个数

八进制，用 1 位数表示 3 个位（bit）

十六进制，用 1 位数表示 4 个位（bit）

1 个字节可以表示的 10 进制数是从 0 到 255，8 进制数是从 000 到 377，16 进制数是从 00 到 FF。

1 个字节有 8 位已经是业界的常识了。由于 2 个 16 进制位刚好等于 8 位（1 个字节），因此用 16 进制来表示以字节为单位的数据会非常方便。



## 12.7 随机数

`rand`，返回比1小的浮点数

`rand(2)` 或 `rand(2.0)` ，返回大于等于0，小于2的整数



## 12.8 计数

`n.times`，循环 n 次

```
ary = []
4.times{|i| ary<<i}
ary  #=> [0, 1, 2, 3]
```

`a.upto(b)`，对 a 进行加一处理

```
ary = []
2.upto(5){|i| ary<<i}
ary  #=> [2, 3, 4, 5]
```

`a.downto(b)`，对 a 进行减一处理

```
ary = []
9.downto(2){|i| ary<<i}
ary  #=> [9, 8, 7, 6, 5, 4, 3, 2]
```

`a.step(b, c)`，对 a 进行加 c 处理

```
ary = []
2.step(12, 3){|i| ary<<i}
ary  #=> [2, 5, 8, 11]
```

如果不对 `times`、`upto`、`downto`、`step` 的各方法指定块，则会返回 `Enumerator` 对象

```
7.times  #=> #<Enumerator: 7:times>
```



## 12.9 近似值误差

如果要用 2 进制的和来表示这类数值的话，计算机就必须在适当的位置截断计算结果，这样就产生了近似值误差

```
a = 0.1 + 0.2  #=> 0.30000000000000004
b = 0.3        #=> 0.3
a == b         #=> false
```

转化成分数，可以避免近似值误差

```
a = Rational(1, 10) + Rational(2, 10)  #=> (3/10)
b = Rational(3, 10)										 #=> (3/10)
a == b																 #=> true
```

`Comparable` 模块里封装了比较运算符，将其 Mix-in 到类后，就可以实现实例间互相比较

```
include Comparable
```



## 练习题